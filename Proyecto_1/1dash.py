import streamlit as st
import pandas as pd
import os
from datetime import datetime
import numpy as np
import json
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import io

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Gestor de CSV - Dashboard",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Carpeta donde est√°n los CSV
CARPETA = r"C:\\BELTRAN\\Ciencia\\MINERIA\\TP1"

def listar_csv():
    """Listar todos los archivos CSV disponibles"""
    try:
        archivos = [f for f in os.listdir(CARPETA) if f.endswith(".csv")]
        return archivos
    except FileNotFoundError:
        st.error(f"‚ùå No se encontr√≥ la carpeta: {CARPETA}")
        return []

def cargar_datos(archivo):
    """Cargar datos desde CSV"""
    ruta = os.path.join(CARPETA, archivo)
    try:
        df = pd.read_csv(ruta)
        return df, ruta
    except Exception as e:
        st.error(f"Error al cargar el archivo: {e}")
        return pd.DataFrame(), ruta

def guardar_datos(df, ruta):
    """Guardar DataFrame en archivo CSV"""
    try:
        df.to_csv(ruta, index=False)
        return True
    except Exception as e:
        st.error(f"Error al guardar: {e}")
        return False

def detectar_columna_id(df):
    """Detectar autom√°ticamente la columna que funciona como ID"""
    if df.empty:
        return None
    
    # Patrones comunes para columnas de ID
    patrones_id = [
        'id', 'ID', 'Id', 'codigo', 'cod', 'codigo', 'numero', 'nro', 
        'clave', 'key', 'identificador'
    ]
    
    # Buscar en nombres de columnas
    for col in df.columns:
        col_lower = col.lower()
        
        # Verificar si el nombre de la columna contiene alg√∫n patr√≥n de ID
        for patron in patrones_id:
            if patron in col_lower:
                return col
        
        # Verificar si la columna tiene valores √∫nicos y secuenciales (como un ID)
        if (df[col].dtype in ['int64', 'float64'] and 
            len(df[col].unique()) == len(df)):
            # Verificar si es secuencial (aproximadamente)
            valores_ordenados = sorted(df[col].unique())
            if len(valores_ordenados) > 1:
                diferencias = [valores_ordenados[i+1] - valores_ordenados[i] for i in range(len(valores_ordenados)-1)]
                if all(diff == 1 for diff in diferencias):
                    return col
    
    # Si no encuentra, usar la primera columna num√©rica
    columnas_numericas = df.select_dtypes(include=['int64', 'float64']).columns
    if len(columnas_numericas) > 0:
        return columnas_numericas[0]
    
    return None

def obtener_siguiente_id(df, columna_id):
    """Obtener el siguiente ID autom√°ticamente"""
    if df.empty or columna_id is None:
        return 1
    
    if columna_id in df.columns:
        try:
            # Convertir a num√©rico y ignorar valores no num√©ricos
            ids_numericos = pd.to_numeric(df[columna_id], errors='coerce')
            ids_numericos = ids_numericos.dropna()
            
            if len(ids_numericos) > 0:
                siguiente = int(ids_numericos.max()) + 1
            else:
                siguiente = len(df) + 1
        except:
            siguiente = len(df) + 1
    else:
        siguiente = len(df) + 1
    
    return siguiente

def generar_graficos(df):
    """Generar gr√°ficos estad√≠sticos basados en los datos"""
    graficos = []
    
    # Identificar columnas num√©ricas y categ√≥ricas
    columnas_numericas = df.select_dtypes(include=[np.number]).columns.tolist()
    columnas_categoricas = df.select_dtypes(include=['object']).columns.tolist()
    
    # Gr√°fico 1: Distribuci√≥n de variables num√©ricas
    if len(columnas_numericas) > 0:
        for col in columnas_numericas[:3]:  # M√°ximo 3 columnas num√©ricas
            try:
                fig = px.histogram(df, x=col, title=f'Distribuci√≥n de {col}', 
                                 template='plotly_white')
                fig.update_layout(height=400)
                graficos.append((f"hist_{col}", fig))
            except Exception as e:
                st.warning(f"No se pudo generar histograma para {col}: {e}")
    
    # Gr√°fico 2: Boxplot para variables num√©ricas
    if len(columnas_numericas) > 0:
        try:
            fig = px.box(df, y=columnas_numericas[:3], 
                        title='Diagrama de Caja - Variables Num√©ricas',
                        template='plotly_white')
            fig.update_layout(height=400)
            graficos.append(("boxplot", fig))
        except Exception as e:
            st.warning(f"No se pudo generar boxplot: {e}")
    
    # Gr√°fico 3: Conteo de categor√≠as
    if len(columnas_categoricas) > 0:
        for col in columnas_categoricas[:2]:  # M√°ximo 2 columnas categ√≥ricas
            try:
                counts = df[col].value_counts().head(10)  # Top 10 categor√≠as
                fig = px.bar(x=counts.index, y=counts.values, 
                           title=f'Top 10 - {col}',
                           labels={'x': col, 'y': 'Count'},
                           template='plotly_white')
                fig.update_layout(height=400)
                graficos.append((f"bar_{col}", fig))
            except Exception as e:
                st.warning(f"No se pudo generar gr√°fico de barras para {col}: {e}")
    
    # Gr√°fico 4: Correlaci√≥n entre variables num√©ricas
    if len(columnas_numericas) >= 2:
        try:
            corr_matrix = df[columnas_numericas].corr()
            fig = px.imshow(corr_matrix, 
                          title='Matriz de Correlaci√≥n',
                          color_continuous_scale='RdBu_r',
                          aspect="auto",
                          template='plotly_white')
            fig.update_layout(height=500)
            graficos.append(("correlation", fig))
        except Exception as e:
            st.warning(f"No se pudo generar matriz de correlaci√≥n: {e}")
    
    # Gr√°fico 5: Scatter plot si hay al menos 2 variables num√©ricas
    if len(columnas_numericas) >= 2:
        try:
            fig = px.scatter(df, x=columnas_numericas[0], y=columnas_numericas[1],
                           title=f'Relaci√≥n entre {columnas_numericas[0]} y {columnas_numericas[1]}',
                           template='plotly_white')
            fig.update_layout(height=400)
            graficos.append(("scatter", fig))
        except Exception as e:
            st.warning(f"No se pudo generar scatter plot: {e}")
    
    # Gr√°fico 6: Series temporales si existe columna de fecha
    columnas_fecha = [col for col in df.columns if 'fecha' in col.lower() or 'date' in col.lower() or 'time' in col.lower()]
    if len(columnas_fecha) > 0 and len(columnas_numericas) > 0:
        try:
            fecha_col = columnas_fecha[0]
            # Intentar convertir a datetime
            df_temp = df.copy()
            df_temp[fecha_col] = pd.to_datetime(df_temp[fecha_col], errors='coerce')
            df_temp = df_temp.dropna(subset=[fecha_col])
            
            if len(df_temp) > 0:
                fig = px.line(df_temp, x=fecha_col, y=columnas_numericas[0],
                            title=f'Evoluci√≥n Temporal - {columnas_numericas[0]}',
                            template='plotly_white')
                fig.update_layout(height=400)
                graficos.append(("time_series", fig))
        except Exception as e:
            st.warning(f"No se pudo generar serie temporal: {e}")
    
    return graficos

def main():
    # T√≠tulo principal
    st.title("Gestor de Archivos CSV ")
    st.markdown("---")
    
    # Sidebar para navegaci√≥n
    st.sidebar.title(" Navegaci√≥n")
    
    # Listar archivos CSV
    archivos = listar_csv()
    
    if not archivos:
        st.error("No se encontraron archivos CSV en la carpeta especificada.")
        return
    
    # Selecci√≥n de archivo en sidebar
    archivo_seleccionado = st.sidebar.selectbox(
        "Selecciona un archivo CSV:",
        archivos,
        key="archivo_selector"
    )
    
    # Cargar datos del archivo seleccionado
    if archivo_seleccionado:
        df, ruta = cargar_datos(archivo_seleccionado)
        
        # Mostrar informaci√≥n del archivo
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric(" Archivo", archivo_seleccionado)
        with col2:
            st.metric(" Registros", len(df))
        with col3:
            st.metric(" Columnas", len(df.columns))
        with col4:
            memoria = df.memory_usage(deep=True).sum() / 1024**2
            st.metric(" Memoria", f"{memoria:.2f} MB")
        
        st.markdown("---")
        
        # Tabs para diferentes funcionalidades - AGREGAMOS NUEVAS PESTA√ëAS
        tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
            "üìã Ver Datos", 
            "‚ûï Insertar", 
            "‚úèÔ∏è Modificar", 
            "üóëÔ∏è Eliminar", 
            "üîç Buscar",
            "üìä Gr√°ficos",  # NUEVA PESTA√ëA
            "üíæ Exportar"   # NUEVA PESTA√ëA
        ])
        
        # Tab 1: Ver Datos
        with tab1:
            st.header("Visualizaci√≥n de Datos")
            
            if not df.empty:
                # Mostrar todos los datos
                st.dataframe(df, use_container_width=True)
                
                
            else:
                st.info("El archivo est√° vac√≠o. Usa la pesta√±a 'Insertar' para agregar datos.")
        
        # Tab 2: Insertar Registro - MEJORADO CON ID AUTOM√ÅTICO
        with tab2:
            st.header("Insertar Nuevo Registro")
            
            if df.empty:
                st.warning("No se pueden insertar registros porque no hay columnas definidas.")
            else:
                # Detectar columna de ID y siguiente ID disponible
                columna_id = detectar_columna_id(df)
                siguiente_id = obtener_siguiente_id(df, columna_id)
                
                st.write("**Columnas disponibles:**", list(df.columns))
                
                if columna_id:
                   # st.success(f"üéØ **Columna de ID detectada:** `{columna_id}`")
                    st.info(f"üÜî **El siguiente ID disponible es:** `{siguiente_id}`")
                
                # Formulario para insertar nuevo registro
                with st.form("form_insertar"):
                    nuevo_registro = {}
                    cols = st.columns(2)  # Dividir en 2 columnas para mejor visualizaci√≥n
                    
                    for i, col in enumerate(df.columns):
                        with cols[i % 2]:  # Alternar entre columnas
                            # Si es la columna de ID, mostrar informaci√≥n especial
                            if col == columna_id:
                                st.markdown(f"**{col}** üÜî")
                                st.caption(f"Siguiente ID: {siguiente_id}")
                                valor = st.text_input(
                                    f"Valor para {col}",
                                    value=str(siguiente_id),
                                    key=f"insert_{col}",
                                    help=f"ID autom√°tico sugerido: {siguiente_id}. Puedes cambiarlo si es necesario."
                                )
                            else:
                                valor = st.text_input(f"{col}", key=f"insert_{col}")
                            
                            nuevo_registro[col] = valor
                    
                    submitted = st.form_submit_button("üíæ Insertar Registro")
                    
                    if submitted:
                        # Validar que no haya campos vac√≠os
                        campos_vacios = [col for col, valor in nuevo_registro.items() if valor == ""]
                        
                        if campos_vacios:
                            st.error(f"Los siguientes campos est√°n vac√≠os: {', '.join(campos_vacios)}")
                        else:
                            # Validar ID √∫nico si es columna de ID
                            if columna_id and columna_id in nuevo_registro:
                                try:
                                    id_ingresado = int(nuevo_registro[columna_id])
                                    # Verificar si el ID ya existe
                                    if columna_id in df.columns:
                                        ids_existentes = pd.to_numeric(df[columna_id], errors='coerce').dropna()
                                        if id_ingresado in ids_existentes.values:
                                            st.error(f"‚ùå El ID {id_ingresado} ya existe en la base de datos.")
                                            st.info(f"üí° El siguiente ID disponible es: {siguiente_id}")
                                            st.stop()
                                    
                                    # Advertencia si el ID no es secuencial
                                    if id_ingresado != siguiente_id:
                                        st.warning(f"‚ö†Ô∏è El ID ingresado ({id_ingresado}) no es secuencial. El siguiente ID ser√≠a: {siguiente_id}")
                                        if not st.checkbox("‚úÖ Confirmar que deseo usar este ID no secuencial"):
                                            st.stop()
                                
                                except ValueError:
                                    st.error(f"‚ùå El valor para {columna_id} debe ser un n√∫mero entero.")
                                    st.stop()
                            
                            # Convertir tipos de datos
                            registro_convertido = {}
                            for col, valor in nuevo_registro.items():
                                if df[col].dtype in ['int64', 'float64']:
                                    try:
                                        if '.' in valor:
                                            registro_convertido[col] = float(valor)
                                        else:
                                            registro_convertido[col] = int(valor)
                                    except ValueError:
                                        registro_convertido[col] = valor
                                else:
                                    registro_convertido[col] = valor
                            
                            # Agregar el nuevo registro
                            nuevo_df = pd.DataFrame([registro_convertido])
                            df = pd.concat([df, nuevo_df], ignore_index=True)
                            
                            # Guardar autom√°ticamente
                            if guardar_datos(df, ruta):
                                st.success(" ‚úÖ Registro insertado y guardado exitosamente!")
                                st.balloons()
                                st.rerun()
                            else:
                                st.error(" ‚ùå Error al guardar el registro")
        
        # Tab 3: Modificar Registro
        with tab3:
            st.header("Modificar Registro Existente")
            
            if df.empty:
                st.info("No hay registros para modificar.")
            else:
                # Seleccionar registro a modificar
                indice_modificar = st.selectbox(
                    "Selecciona el √≠ndice del registro a modificar:",
                    range(len(df)),
                    format_func=lambda x: f"Registro {x}: {dict(df.iloc[x])}"
                )
                
                if st.button("Cargar Registro para Modificar"):
                    registro_actual = df.iloc[indice_modificar]
                    st.session_state.registro_modificar = registro_actual.copy()
                    st.session_state.indice_modificar = indice_modificar
                
                if 'registro_modificar' in st.session_state:
                    st.subheader("Modificando Registro:")
                    st.write(st.session_state.registro_modificar)
                    
                    with st.form("form_modificar"):
                        registro_modificado = {}
                        cols = st.columns(2)
                        
                        for i, col in enumerate(df.columns):
                            with cols[i % 2]:
                                valor_actual = st.session_state.registro_modificar[col]
                                nuevo_valor = st.text_input(
                                    f"{col}", 
                                    value=str(valor_actual),
                                    key=f"mod_{col}"
                                )
                                registro_modificado[col] = nuevo_valor
                        
                        submitted = st.form_submit_button(" üíæ Guardar Cambios")
                        
                        if submitted:
                            # Aplicar cambios
                            for col, valor in registro_modificado.items():
                                if valor != str(st.session_state.registro_modificar[col]):
                                    # Convertir tipo de dato si es necesario
                                    if df[col].dtype in ['int64', 'float64']:
                                        try:
                                            if '.' in valor:
                                                df.at[st.session_state.indice_modificar, col] = float(valor)
                                            else:
                                                df.at[st.session_state.indice_modificar, col] = int(valor)
                                        except ValueError:
                                            df.at[st.session_state.indice_modificar, col] = valor
                                    else:
                                        df.at[st.session_state.indice_modificar, col] = valor
                            
                            # Guardar cambios
                            if guardar_datos(df, ruta):
                                st.success(" ‚úÖ Registro modificado exitosamente!")
                                del st.session_state.registro_modificar
                                del st.session_state.indice_modificar
                                st.rerun()
                            else:
                                st.error(" ‚ùå Error al guardar los cambios")
        
        # Tab 4: Eliminar Registro - SOLUCI√ìN DEFINITIVA
        with tab4:
            st.header("üóëÔ∏è Eliminar Registros")
            
            if df.empty:
                st.info("No hay registros para eliminar.")
            else:
                # Usar multiselect para selecci√≥n simple
                opciones = [f"Registro {i}: {', '.join([f'{k}={v}' for k, v in df.iloc[i].items()])}" for i in range(len(df))]
                
                seleccion = st.multiselect(
                    "Selecciona los registros a eliminar:",
                    options=range(len(df)),
                    format_func=lambda x: f"Registro {x}: {', '.join([f'{k}={v}' for k, v in df.iloc[x].items()])}"
                )
                
                if seleccion:
                    st.subheader("üìã Registros seleccionados para eliminar:")
                    st.dataframe(df.iloc[seleccion], use_container_width=True)
                    
                    st.warning(f"‚ö†Ô∏è Se eliminar√°n {len(seleccion)} registro(s). Esta acci√≥n no se puede deshacer.")
                    
                    if st.button("üóëÔ∏è CONFIRMAR ELIMINACI√ìN", type="primary"):
                        # ELIMINAR Y ACTUALIZAR
                        try:
                            # Crear copia del DataFrame sin los registros seleccionados
                            df_nuevo = df.drop(seleccion).reset_index(drop=True)
                            
                            # Guardar en el archivo
                            exito = guardar_datos(df_nuevo, ruta)
                            
                            if exito:
                                st.success(f" ‚úÖ {len(seleccion)} registro(s) eliminado(s) exitosamente!")
                                
                                # ACTUALIZAR EL DATAFRAME GLOBAL - ESTO ES CLAVE
                                # Necesitamos forzar la recarga del archivo
                                df, ruta = cargar_datos(archivo_seleccionado)
                                
                                st.info(" Datos actualizados correctamente")
                                st.rerun()
                            else:
                                st.error(" ‚ùå Error al guardar los cambios")
                                
                        except Exception as e:
                            st.error(f" ‚ùå Error: {e}")
                else:
                    st.info(" Selecciona registros de la lista para eliminarlos")
        
        # Tab 5: Buscar Registros
        with tab5:
            st.header("Buscar Registros")
            
            if df.empty:
                st.info("No hay registros para buscar.")
            else:
                col_busqueda, valor_busqueda = st.columns(2)
                
                with col_busqueda:
                    columna_buscar = st.selectbox(
                        "Columna para buscar:",
                        df.columns
                    )
                
                with valor_busqueda:
                    valor_buscar = st.text_input("Valor a buscar:")
                
                if valor_buscar:
                    # Realizar b√∫squeda
                    try:
                        if df[columna_buscar].dtype in ['int64', 'float64']:
                            # B√∫squeda num√©rica
                            if '.' in valor_buscar:
                                valor_buscar = float(valor_buscar)
                            else:
                                valor_buscar = int(valor_buscar)
                            resultados = df[df[columna_buscar] == valor_buscar]
                        else:
                            # B√∫squeda textual
                            resultados = df[df[columna_buscar].astype(str).str.contains(valor_buscar, case=False)]
                    except ValueError:
                        # Si falla la conversi√≥n, buscar como texto
                        resultados = df[df[columna_buscar].astype(str).str.contains(valor_buscar, case=False)]
                    
                    if len(resultados) > 0:
                        st.success(f" ‚úÖ Se encontraron {len(resultados)} registros:")
                        st.dataframe(resultados, use_container_width=True)
                    else:
                        st.info("No se encontraron registros que coincidan con la b√∫squeda.")
        
        # NUEVA TAB 6: GR√ÅFICOS ESTAD√çSTICOS
        with tab6:
            st.header("üìä An√°lisis Gr√°fico y Estad√≠stico")
            
            if df.empty:
                st.info("No hay datos para generar gr√°ficos.")
            else:
                # Selector de tipo de gr√°fico
                st.subheader("Configuraci√≥n de Gr√°ficos")
                
                # Generar gr√°ficos autom√°ticamente
                st.subheader("Gr√°ficos Autom√°ticos")
                graficos = generar_graficos(df)
                
                if graficos:
                    for nombre, fig in graficos:
                        st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("No se pudieron generar gr√°ficos autom√°ticamente con los datos disponibles.")
                
               
        
        # NUEVA TAB 7: EXPORTAR DATOS
        with tab7:
            st.header("üíæ Exportar Datos")
            
            if df.empty:
                st.info("No hay datos para exportar.")
            else:
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Exportar Formato CSV")
                    nombre_csv = st.text_input("Nombre del archivo CSV:", 
                                             value=f"{archivo_seleccionado.split('.')[0]}_export.csv")
                    
                    csv_data = df.to_csv(index=False)
                    st.download_button(
                        label="üì• Descargar CSV",
                        data=csv_data,
                        file_name=nombre_csv,
                        mime="text/csv",
                        key="download_csv"
                    )
                
                with col2:
                    st.subheader("Exportar Formato JSON")
                    nombre_json = st.text_input("Nombre del archivo JSON:", 
                                              value=f"{archivo_seleccionado.split('.')[0]}_export.json")
                    
                    # Opciones de formato JSON
                    formato_json = st.radio("Formato JSON:", 
                                          ["Records", "Split", "Values"], 
                                          help="Records: lista de objetos, Split: separado en √≠ndices y datos, Values: solo valores")
                    
                    if formato_json == "Records":
                        json_data = df.to_json(orient='records', indent=2)
                    elif formato_json == "Split":
                        json_data = df.to_json(orient='split', indent=2)
                    else:
                        json_data = df.to_json(orient='values', indent=2)
                    
                    st.download_button(
                        label="üì• Descargar JSON",
                        data=json_data,
                        file_name=nombre_json,
                        mime="application/json",
                        key="download_json"
                    )
                
                st.markdown("---")
                
                # Exportaci√≥n avanzada
                st.subheader("Opciones Avanzadas de Exportaci√≥n")
                
                col3, col4 = st.columns(2)
                
                with col3:
                    st.subheader("Exportar a Excel")
                    nombre_excel = st.text_input("Nombre del archivo Excel:", 
                                               value=f"{archivo_seleccionado.split('.')[0]}_export.xlsx")
                    
                    # Crear archivo Excel en memoria
                    excel_buffer = io.BytesIO()
                    with pd.ExcelWriter(excel_buffer, engine='xlsxwriter') as writer:
                        df.to_excel(writer, sheet_name='Datos', index=False)
                        
                        # Agregar hoja con estad√≠sticas si hay columnas num√©ricas
                        columnas_numericas = df.select_dtypes(include=[np.number]).columns
                        if len(columnas_numericas) > 0:
                            df[columnas_numericas].describe().to_excel(writer, sheet_name='Estad√≠sticas')
                    
                    excel_data = excel_buffer.getvalue()
                    
                    st.download_button(
                        label="üì• Descargar Excel",
                        data=excel_data,
                        file_name=nombre_excel,
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        key="download_excel"
                    )
                
                with col4:
                    st.subheader("Exportar Datos Filtrados")
                    st.info("Selecciona columnas espec√≠ficas para exportar:")
                    
                    columnas_exportar = st.multiselect(
                        "Selecciona columnas:",
                        df.columns.tolist(),
                        default=df.columns.tolist()
                    )
                    
                    if columnas_exportar:
                        df_filtrado = df[columnas_exportar]
                        
                        formato_filtrado = st.selectbox("Formato para datos filtrados:", 
                                                      ["CSV", "JSON"])
                        
                        nombre_filtrado = st.text_input("Nombre archivo filtrado:",
                                                      value=f"{archivo_seleccionado.split('.')[0]}_filtrado.{formato_filtrado.lower()}")
                        
                        if formato_filtrado == "CSV":
                            data_filtrado = df_filtrado.to_csv(index=False)
                            mime_type = "text/csv"
                        else:
                            data_filtrado = df_filtrado.to_json(orient='records', indent=2)
                            mime_type = "application/json"
                        
                        st.download_button(
                            label=f"üì• Descargar {formato_filtrado} Filtrado",
                            data=data_filtrado,
                            file_name=nombre_filtrado,
                            mime=mime_type,
                            key="download_filtered"
                        )
        
        
        
        # Informaci√≥n adicional en sidebar
        st.sidebar.markdown("---")
        st.sidebar.header("‚Ñπ Informaci√≥n")
        st.sidebar.write(f"**Carpeta:** {CARPETA}")
        st.sidebar.write(f"**√öltima actualizaci√≥n:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Estad√≠sticas r√°pidas en sidebar
        if not df.empty:
            st.sidebar.markdown("---")
            st.sidebar.header("üìä Resumen")
            st.sidebar.write(f"**Registros:** {len(df)}")
            st.sidebar.write(f"**Columnas:** {len(df.columns)}")
            
            columnas_numericas = df.select_dtypes(include=[np.number]).columns
            if len(columnas_numericas) > 0:
                st.sidebar.write(f"**Columnas num√©ricas:** {len(columnas_numericas)}")
            
            nulos = df.isnull().sum().sum()
            if nulos > 0:
                st.sidebar.warning(f"**Valores nulos:** {nulos}")

if __name__ == "__main__":
    main()